-- ============================================================================
-- Nebula Graph Schema for SuperCore RAG Graph Layer
-- ============================================================================
-- This schema defines the graph structure for mapping relationships between
-- ObjectDefinitions and Instances in the SuperCore platform.
--
-- Architecture:
-- - Tags (Vertex Types): ObjectDefinition, Instance
-- - Edge Types: DEFINES, RELATES_TO, INHERITS_FROM
-- ============================================================================

-- Create Space (Database)
CREATE SPACE IF NOT EXISTS supercore_graph (
  partition_num = 10,
  replica_factor = 1,
  vid_type = FIXED_STRING(36)
)
COMMENT = 'SuperCore RAG Graph Layer - Object and Instance Relationships';

-- Use the space
USE supercore_graph;

-- ============================================================================
-- TAG DEFINITIONS (Vertex Types)
-- ============================================================================

-- ObjectDefinition Tag
-- Represents meta-model object definitions (e.g., Invoice, Payment, Client)
CREATE TAG IF NOT EXISTS ObjectDefinition (
  name STRING NOT NULL COMMENT 'Object name (e.g., Invoice)',
  category STRING COMMENT 'Category (FINANCIAL, OPERATIONAL, etc)',
  version INT DEFAULT 1 COMMENT 'Schema version',
  description STRING COMMENT 'Human-readable description',
  created_at DATETIME COMMENT 'Creation timestamp',
  updated_at DATETIME COMMENT 'Last update timestamp'
)
TTL_DURATION = 0, TTL_COL = ""
COMMENT = 'Meta-model object definitions';

-- Instance Tag
-- Represents concrete instances of objects (e.g., specific invoice #123)
CREATE TAG IF NOT EXISTS Instance (
  object_definition_id STRING NOT NULL COMMENT 'Reference to ObjectDefinition UUID',
  object_definition_name STRING NOT NULL COMMENT 'Cached object name for quick access',
  current_state STRING COMMENT 'Current state (e.g., PENDING, APPROVED)',
  data TEXT COMMENT 'Instance data as JSONB',
  created_at DATETIME COMMENT 'Creation timestamp',
  updated_at DATETIME COMMENT 'Last update timestamp',
  created_by STRING COMMENT 'User who created this instance'
)
TTL_DURATION = 0, TTL_COL = ""
COMMENT = 'Concrete instances of objects';

-- ============================================================================
-- EDGE TYPE DEFINITIONS (Relationship Types)
-- ============================================================================

-- DEFINES Edge
-- Links ObjectDefinition to its Instances
-- Direction: ObjectDefinition -> Instance
CREATE EDGE IF NOT EXISTS DEFINES (
  created_at DATETIME COMMENT 'When this relationship was created'
)
TTL_DURATION = 0, TTL_COL = ""
COMMENT = 'ObjectDefinition defines Instance';

-- RELATES_TO Edge
-- Links Instance to Instance (any type of relationship)
-- Direction: Instance -> Instance
CREATE EDGE IF NOT EXISTS RELATES_TO (
  relationship_type STRING NOT NULL COMMENT 'Type of relationship (e.g., PAYMENT_FOR, DEPENDS_ON)',
  metadata TEXT COMMENT 'Additional relationship metadata as JSON',
  created_at DATETIME COMMENT 'When this relationship was created',
  created_by STRING COMMENT 'User who created this relationship'
)
TTL_DURATION = 0, TTL_COL = ""
COMMENT = 'Instance relates to another Instance';

-- INHERITS_FROM Edge
-- Links ObjectDefinition to parent ObjectDefinition (inheritance)
-- Direction: ObjectDefinition -> ObjectDefinition (parent)
CREATE EDGE IF NOT EXISTS INHERITS_FROM (
  created_at DATETIME COMMENT 'When this inheritance was defined'
)
TTL_DURATION = 0, TTL_COL = ""
COMMENT = 'ObjectDefinition inherits from parent ObjectDefinition';

-- ============================================================================
-- INDEXES FOR PERFORMANCE
-- ============================================================================

-- Index on ObjectDefinition.name for fast lookups
CREATE TAG INDEX IF NOT EXISTS idx_objectdef_name ON ObjectDefinition(name(20));

-- Index on ObjectDefinition.category for filtering
CREATE TAG INDEX IF NOT EXISTS idx_objectdef_category ON ObjectDefinition(category(20));

-- Index on Instance.object_definition_id for filtering by type
CREATE TAG INDEX IF NOT EXISTS idx_instance_objdef_id ON Instance(object_definition_id(36));

-- Index on Instance.current_state for state-based queries
CREATE TAG INDEX IF NOT EXISTS idx_instance_state ON Instance(current_state(20));

-- Index on RELATES_TO.relationship_type for filtering relationship types
CREATE EDGE INDEX IF NOT EXISTS idx_relates_type ON RELATES_TO(relationship_type(30));

-- ============================================================================
-- REBUILD INDEXES (Run after schema creation)
-- ============================================================================
-- Note: Uncomment and run these commands after creating the schema:
-- REBUILD TAG INDEX idx_objectdef_name;
-- REBUILD TAG INDEX idx_objectdef_category;
-- REBUILD TAG INDEX idx_instance_objdef_id;
-- REBUILD TAG INDEX idx_instance_state;
-- REBUILD EDGE INDEX idx_relates_type;

-- ============================================================================
-- EXAMPLE QUERIES
-- ============================================================================

-- Find all instances of a specific object type:
-- MATCH (od:ObjectDefinition {name: "Invoice"})-[:DEFINES]->(i:Instance)
-- RETURN i;

-- Find all related instances up to 2 levels deep:
-- MATCH (i:Instance {id: "uuid-here"})-[:RELATES_TO*1..2]->(related:Instance)
-- RETURN related;

-- Find shortest path between two instances:
-- FIND SHORTEST PATH FROM "instance-uuid-1" TO "instance-uuid-2" OVER RELATES_TO;

-- Analyze impact (find all instances that depend on a specific instance):
-- MATCH (target:Instance {id: "uuid-here"})<-[:RELATES_TO]-(dependent:Instance)
-- RETURN dependent;

-- Find inheritance hierarchy:
-- MATCH (od:ObjectDefinition {name: "SpecializedInvoice"})-[:INHERITS_FROM*]->(parent:ObjectDefinition)
-- RETURN parent;
